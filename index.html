<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Фрактал Мандельброта</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            font-family: Arial, sans-serif;
            background: #000;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            padding: 0 20px;
            z-index: 100;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            text-align: center;
            z-index: 1000;
        }
        .progress {
            width: 80%;
            max-width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            margin: 10px auto;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff8a00, #e52e71);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="loading">
        <div>Загрузка 3D фрактала...</div>
        <div class="progress">
            <div class="progress-bar" id="progressBar"></div>
        </div>
        <div id="progressText">0%</div>
    </div>
    <div class="controls">Свайп для перемещения · Два пальца для масштабирования</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Основные переменные
            let camera, scene, renderer;
            let fractalMesh;
            let isRotating = false;
            let previousTouchDistance = null;
            let initialTouches = [];
            
            // Параметры фрактала - упрощенные для тестирования
            const fractalParams = {
                resolution: 24,  // Среднее разрешение для баланса скорости/качества
                iterations: 8,
                scale: 2.0,
                power: 8,
                threshold: 2.0  // Изменен порог для лучшего отображения
            };
            
            // Элементы прогресса
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            let totalPoints = 0;
            let processedPoints = 0;
            
            // Инициализация сцены
            function init() {
                // Создание сцены
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x001122); // Темно-синий фон вместо черного
                
                // Создание камеры
                const aspectRatio = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 1000);
                camera.position.set(0, 0, 5);
                
                // Создание рендерера
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);
                
                // Добавление освещения
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 10);
                scene.add(directionalLight);
                
                // Создание простого тестового объекта для проверки
                createTestObject();
                
                // Обработка событий
                setupEventListeners();
                
                // Запуск анимации
                animate();
                
                // Начинаем генерацию фрактала после небольшой задержки
                setTimeout(createFractalWithProgress, 100);
            }
            
            // Создание тестового объекта для проверки отображения
            function createTestObject() {
                const geometry = new THREE.SphereGeometry(1, 16, 16);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    wireframe: true 
                });
                const testSphere = new THREE.Mesh(geometry, material);
                scene.add(testSphere);
                
                // Удалим его через 2 секунды
                setTimeout(() => {
                    scene.remove(testSphere);
                }, 2000);
            }
            
            // Создание 3D фрактала с индикатором прогресса
            function createFractalWithProgress() {
                // Создание геометрии для точек фрактала
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                // Генерация точек фрактала
                const size = fractalParams.resolution;
                const halfSize = size / 2;
                
                // Вычисление общего количества точек
                totalPoints = size * size * size;
                processedPoints = 0;
                
                // Создание фрактала по частям с помощью requestAnimationFrame
                let x = 0, y = 0, z = 0;
                
                function generateNextBatch() {
                    const batchSize = 500; // Количество точек за один кадр
                    let pointsGenerated = 0;
                    
                    while (pointsGenerated < batchSize && z < size) {
                        // Нормализованные координаты
                        const nx = (x - halfSize) / halfSize * fractalParams.scale;
                        const ny = (y - halfSize) / halfSize * fractalParams.scale;
                        const nz = (z - halfSize) / halfSize * fractalParams.scale;
                        
                        // Вычисление фрактала
                        const value = mandelbulb(nx, ny, nz, fractalParams);
                        
                        // Упрощенное условие для отображения точек
                        if (value < fractalParams.threshold && value > 0) {
                            positions.push(nx, ny, nz);
                            
                            // Цвет на основе значения фрактала
                            const colorIntensity = Math.min(1, value / fractalParams.threshold);
                            colors.push(
                                colorIntensity * 0.8 + 0.2,
                                colorIntensity * 0.5 + 0.3,
                                colorIntensity * 0.3 + 0.7
                            );
                        }
                        
                        // Переход к следующей точке
                        x++;
                        if (x >= size) {
                            x = 0;
                            y++;
                            if (y >= size) {
                                y = 0;
                                z++;
                            }
                        }
                        
                        pointsGenerated++;
                        processedPoints++;
                    }
                    
                    // Обновление прогресса
                    const progress = (processedPoints / totalPoints) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = Math.round(progress) + '%';
                    
                    if (z < size) {
                        // Продолжаем генерацию
                        requestAnimationFrame(generateNextBatch);
                    } else {
                        // Завершение генерации
                        finishFractalGeneration(geometry, positions, colors);
                    }
                }
                
                // Запуск генерации
                generateNextBatch();
            }
            
            // Завершение генерации фрактала
            function finishFractalGeneration(geometry, positions, colors) {
                if (positions.length === 0) {
                    // Если точек нет, создаем простой фрактал
                    createSimpleFractal();
                    return;
                }
                
                // Установка атрибутов геометрии
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                // Материал для точек
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                // Создание mesh
                fractalMesh = new THREE.Points(geometry, material);
                scene.add(fractalMesh);
                
                // Скрытие сообщения о загрузке
                setTimeout(() => {
                    document.querySelector('.loading').style.display = 'none';
                }, 500);
            }
            
            // Создание простого фрактала если основной не сработал
            function createSimpleFractal() {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                // Создаем простой фрактальный узор
                const size = 20;
                for (let x = 0; x < size; x++) {
                    for (let y = 0; y < size; y++) {
                        for (let z = 0; z < size; z++) {
                            const nx = (x - size/2) / 5;
                            const ny = (y - size/2) / 5;
                            const nz = (z - size/2) / 5;
                            
                            // Простой фрактальный паттерн
                            const r = Math.sqrt(nx*nx + ny*ny + nz*nz);
                            const value = Math.sin(r * 10) * Math.cos(nx * 5) * Math.sin(ny * 5);
                            
                            if (Math.abs(value) > 0.3) {
                                positions.push(nx, ny, nz);
                                colors.push(
                                    (x / size) * 0.8 + 0.2,
                                    (y / size) * 0.5 + 0.3,
                                    (z / size) * 0.7 + 0.3
                                );
                            }
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                
                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    sizeAttenuation: true
                });
                
                fractalMesh = new THREE.Points(geometry, material);
                scene.add(fractalMesh);
                
                document.querySelector('.loading').style.display = 'none';
            }
            
            // Упрощенная функция для вычисления 3D фрактала
            function mandelbulb(x, y, z, params) {
                let zx = x;
                let zy = y;
                let zz = z;
                
                for (let i = 0; i < params.iterations; i++) {
                    const r = Math.sqrt(zx*zx + zy*zy + zz*zz);
                    if (r > 2) return i / params.iterations;
                    
                    // Простое преобразование
                    const theta = Math.atan2(Math.sqrt(zx*zx + zy*zy), zz);
                    const phi = Math.atan2(zy, zx);
                    
                    const zr = Math.pow(r, params.power);
                    const newTheta = theta * params.power;
                    const newPhi = phi * params.power;
                    
                    zx = zr * Math.sin(newTheta) * Math.cos(newPhi) + x;
                    zy = zr * Math.sin(newTheta) * Math.sin(newPhi) + y;
                    zz = zr * Math.cos(newTheta) + z;
                }
                
                return 0;
            }
            
            // Настройка обработчиков событий
            function setupEventListeners() {
                // Обработка одинарных касаний (перетаскивание)
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                
                // Обработка изменения размера окна
                window.addEventListener('resize', onWindowResize, false);
            }
            
            // Обработка начала касания
            function onTouchStart(event) {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    isRotating = true;
                    initialTouches = [{
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    }];
                } else if (event.touches.length === 2) {
                    isRotating = false;
                    // Расчет начального расстояния между двумя пальцами
                    previousTouchDistance = Math.hypot(
                        event.touches[0].clientX - event.touches[1].clientX,
                        event.touches[0].clientY - event.touches[1].clientY
                    );
                }
            }
            
            // Обработка перемещения пальцев
            function onTouchMove(event) {
                event.preventDefault();
                
                if (event.touches.length === 1 && isRotating) {
                    // Вращение фрактала
                    const touchX = event.touches[0].clientX;
                    const touchY = event.touches[0].clientY;
                    
                    const movementX = touchX - initialTouches[0].x;
                    const movementY = touchY - initialTouches[0].y;
                    
                    if (fractalMesh) {
                        fractalMesh.rotation.y += movementX * 0.01;
                        fractalMesh.rotation.x += movementY * 0.01;
                    }
                    
                    initialTouches[0] = { x: touchX, y: touchY };
                } else if (event.touches.length === 2) {
                    // Масштабирование
                    const touchDistance = Math.hypot(
                        event.touches[0].clientX - event.touches[1].clientX,
                        event.touches[0].clientY - event.touches[1].clientY
                    );
                    
                    if (previousTouchDistance !== null) {
                        const zoomFactor = touchDistance / previousTouchDistance;
                        camera.position.z *= 1 / zoomFactor;
                        camera.position.z = Math.max(2, Math.min(20, camera.position.z));
                    }
                    
                    previousTouchDistance = touchDistance;
                }
            }
            
            // Обработка завершения касания
            function onTouchEnd(event) {
                event.preventDefault();
                isRotating = false;
                previousTouchDistance = null;
            }
            
            // Обработка изменения размера окна
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Функция анимации
            function animate() {
                requestAnimationFrame(animate);
                
                // Медленное автоматическое вращение
                if (fractalMesh) {
                    fractalMesh.rotation.y += 0.002;
                }
                
                renderer.render(scene, camera);
            }
            
            // Запуск инициализации
            init();
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Фрактал для мобильных</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            font-family: Arial, sans-serif;
            background: #000;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            padding: 0 20px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="controls">Свайп для вращения · Два пальца для масштабирования</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let camera, scene, renderer;
            let fractal;
            let isRotating = false;
            let previousTouchDistance = null;
            let initialTouches = [];
            
            // Инициализация сцены
            function init() {
                // Создание сцены
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000011);
                
                // Создание камеры
                const aspectRatio = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
                camera.position.z = 10;
                
                // Создание рендерера
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.body.appendChild(renderer.domElement);
                
                // Добавление освещения
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);
                
                // Создание простого но красивого фрактала
                createSimpleFractal();
                
                // Обработка событий
                setupEventListeners();
                
                // Запуск анимации
                animate();
            }
            
            // Создание простого фрактала на основе геометрии
            function createSimpleFractal() {
                // Создаем группу для фрактала
                fractal = new THREE.Group();
                scene.add(fractal);
                
                // Параметры фрактала
                const size = 1;
                const iterations = 4; // Уровень детализации
                const scaleFactor = 0.5; // Коэффициент масштабирования
                
                // Рекурсивная функция для создания фрактала
                function createLevel(level, parent, scale) {
                    if (level <= 0) return;
                    
                    // Количество объектов на текущем уровне
                    const count = 8;
                    
                    for (let i = 0; i < count; i++) {
                        // Создаем геометрию в зависимости от уровня
                        let geometry;
                        if (level === iterations) {
                            geometry = new THREE.OctahedronGeometry(scale, 0);
                        } else if (level === iterations - 1) {
                            geometry = new THREE.DodecahedronGeometry(scale * 0.8, 0);
                        } else {
                            geometry = new THREE.IcosahedronGeometry(scale * 0.6, 0);
                        }
                        
                        // Материал с разными цветами для уровней
                        const material = new THREE.MeshPhongMaterial({
                            color: new THREE.Color().setHSL(
                                i / count, 
                                0.8, 
                                0.5 + level * 0.1
                            ),
                            transparent: true,
                            opacity: 0.8,
                            wireframe: level < 3 // Проволочный режим для внутренних уровней
                        });
                        
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        // Позиционируем объекты по кругу
                        const angle = (i / count) * Math.PI * 2;
                        const radius = scale * 2;
                        mesh.position.x = Math.cos(angle) * radius;
                        mesh.position.y = Math.sin(angle) * radius;
                        mesh.position.z = (iterations - level) * 0.5;
                        
                        // Добавляем вращение
                        mesh.rotation.x = Math.random() * Math.PI;
                        mesh.rotation.y = Math.random() * Math.PI;
                        
                        parent.add(mesh);
                        
                        // Рекурсивно создаем следующий уровень
                        createLevel(level - 1, mesh, scale * scaleFactor);
                    }
                }
                
                // Запускаем создание фрактала
                createLevel(iterations, fractal, size);
            }
            
            // Настройка обработчиков событий
            function setupEventListeners() {
                // Обработка одинарных касаний (перетаскивание)
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
                
                // Обработка изменения размера окна
                window.addEventListener('resize', onWindowResize, false);
            }
            
            // Обработка начала касания
            function onTouchStart(event) {
                event.preventDefault();
                
                if (event.touches.length === 1) {
                    isRotating = true;
                    initialTouches = [{
                        x: event.touches[0].clientX,
                        y: event.touches[0].clientY
                    }];
                } else if (event.touches.length === 2) {
                    isRotating = false;
                    // Расчет начального расстояния между двумя пальцами
                    previousTouchDistance = Math.hypot(
                        event.touches[0].clientX - event.touches[1].clientX,
                        event.touches[0].clientY - event.touches[1].clientY
                    );
                }
            }
            
            // Обработка перемещения пальцев
            function onTouchMove(event) {
                event.preventDefault();
                
                if (event.touches.length === 1 && isRotating) {
                    // Вращение фрактала
                    const touchX = event.touches[0].clientX;
                    const touchY = event.touches[0].clientY;
                    
                    const movementX = touchX - initialTouches[0].x;
                    const movementY = touchY - initialTouches[0].y;
                    
                    fractal.rotation.y += movementX * 0.01;
                    fractal.rotation.x += movementY * 0.01;
                    
                    initialTouches[0] = { x: touchX, y: touchY };
                } else if (event.touches.length === 2) {
                    // Масштабирование
                    const touchDistance = Math.hypot(
                        event.touches[0].clientX - event.touches[1].clientX,
                        event.touches[0].clientY - event.touches[1].clientY
                    );
                    
                    if (previousTouchDistance !== null) {
                        const zoomFactor = touchDistance / previousTouchDistance;
                        camera.position.z *= 1 / zoomFactor;
                        camera.position.z = Math.max(5, Math.min(50, camera.position.z));
                    }
                    
                    previousTouchDistance = touchDistance;
                }
            }
            
            // Обработка завершения касания
            function onTouchEnd(event) {
                event.preventDefault();
                isRotating = false;
                previousTouchDistance = null;
            }
            
            // Обработка изменения размера окна
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Функция анимации
            function animate() {
                requestAnimationFrame(animate);
                
                // Медленное автоматическое вращение, если пользователь не взаимодействует
                if (!isRotating) {
                    fractal.rotation.y += 0.002;
                    fractal.rotation.x += 0.001;
                }
                
                // Пульсация масштаба для внутренних элементов
                const time = Date.now() * 0.001;
                fractal.children.forEach((child, index) => {
                    if (child.children && child.children.length > 0) {
                        child.children.forEach(grandchild => {
                            grandchild.scale.x = 1 + Math.sin(time + index) * 0.1;
                            grandchild.scale.y = 1 + Math.sin(time + index) * 0.1;
                            grandchild.scale.z = 1 + Math.sin(time + index) * 0.1;
                        });
                    }
                });
                
                renderer.render(scene, camera);
            }
            
            // Запуск инициализации
            init();
        });
    </script>
</body>
</html>
